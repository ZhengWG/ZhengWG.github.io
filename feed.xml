<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.johneyzheng.top//</id><title>Johney Zheng</title><subtitle>不要习惯了黑暗就为黑暗辩护；不要为了自己的苟且而得意，做一个勇敢而热情的人</subtitle> <updated>2024-12-31T14:41:34+08:00</updated> <author> <name>Johney Zheng</name> <uri>https://www.johneyzheng.top//</uri> </author><link rel="self" type="application/atom+xml" href="https://www.johneyzheng.top//feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-Hans" href="https://www.johneyzheng.top//"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2024 Johney Zheng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Modern-C++_工程实践</title><link href="https://www.johneyzheng.top//posts/Modern-C++_%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" rel="alternate" type="text/html" title="Modern-C++_工程实践" /><published>2024-12-30T18:30:00+08:00</published> <updated>2024-12-30T18:30:00+08:00</updated> <id>https://www.johneyzheng.top//posts/Modern-C++_%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id> <content src="https://www.johneyzheng.top//posts/Modern-C++_%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" /> <author> <name>Johney Zheng</name> </author> <category term="语言" /> <summary> 开发环境 编译环境 C++ 编译器是将 C++ 源代码转换为机器代码的工具。不同平台/系统有不同的C++编译器支持，几个主流的C++编译器如下： GCC(GNU Compiler Collection)： 跨平台，Linux常用，与GNU工具链集成，优化能力强，适合高性能计算和嵌入式开发。基础使用： Clang： 跨平台，原生支持macOS，编译速度快，与LLVM工具链集成，错误信息友好，适合开发和调试。 MSVC： Only Windows，与Visual Studio一起提供，集成性能分析工具，适合 Windows 应用开发。 基本使用方式（以GCC/Clang为例）： # 编译并链接 # --std: 指定C++标准 # -Wall: 启用所有警告 # -O2: # -Ii... </summary> </entry> <entry><title>Modern-C++_并发</title><link href="https://www.johneyzheng.top//posts/Modern-C++_%E5%B9%B6%E5%8F%91/" rel="alternate" type="text/html" title="Modern-C++_并发" /><published>2024-12-28T12:30:00+08:00</published> <updated>2024-12-28T12:30:00+08:00</updated> <id>https://www.johneyzheng.top//posts/Modern-C++_%E5%B9%B6%E5%8F%91/</id> <content src="https://www.johneyzheng.top//posts/Modern-C++_%E5%B9%B6%E5%8F%91/" /> <author> <name>Johney Zheng</name> </author> <category term="语言" /> <summary> 并发编程 通俗地说，“并发”是指在一个时间段里有多个操作在同时进行，而“多线程”是实现并发的一种方式。 多线程 线程概念 C++而言，线程就是一个能够独立运行的函数： auto f = []() // 定义一个lambda表达式 { cout &amp;lt;&amp;lt; "thread id:" &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; endl; }; thread t(f); // 启动一个线程：运行函数f 多线程开发 基于基础的thread线程类的简单例子： mutex out_lock; void func(const char* name) { thid_thread::sleep_for(100ms); lock_guard&amp;lt;mutex&amp;gt; guard{ out_lock; }; ... </summary> </entry> <entry><title>LLMs位置编码</title><link href="https://www.johneyzheng.top//posts/LLMs%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/" rel="alternate" type="text/html" title="LLMs位置编码" /><published>2024-12-25T13:00:00+08:00</published> <updated>2024-12-25T13:00:00+08:00</updated> <id>https://www.johneyzheng.top//posts/LLMs%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/</id> <content src="https://www.johneyzheng.top//posts/LLMs%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/" /> <author> <name>Johney Zheng</name> </author> <category term="AI Infra" /> <category term="算法篇" /> <summary> 前言 在大规模语言模型（LLMs, Large Language Models）中，由于 Transformer 模型本身不具备天然的序列感知能力，所以需要引入位置编码的目的是帮助模型捕捉和理解输入序列中位置关系和顺序信息。 绝对位置编码 绝对位置编码将每个位置直接编码为唯一的固定向量。常见的绝对位置编码包括： 可学习位置编码 每个位置对应一个可训练向量，由模型学习其语义，如可学习的Posional Embedding。 固定正弦-余弦位置编码（Sinusoidal PE） Google在Attention Is All You Need提出，使用正弦和余弦函数生成位置向量，周期性和递减频率允许模型自然扩展到未见长度： \[\text{PE}{(pos, 2i)} = \sin(\frac {pos} {10000^{... </summary> </entry> <entry><title>集群通信</title><link href="https://www.johneyzheng.top//posts/%E9%9B%86%E7%BE%A4%E9%80%9A%E4%BF%A1/" rel="alternate" type="text/html" title="集群通信" /><published>2024-12-23T19:00:00+08:00</published> <updated>2024-12-23T19:00:00+08:00</updated> <id>https://www.johneyzheng.top//posts/%E9%9B%86%E7%BE%A4%E9%80%9A%E4%BF%A1/</id> <content src="https://www.johneyzheng.top//posts/%E9%9B%86%E7%BE%A4%E9%80%9A%E4%BF%A1/" /> <author> <name>Johney Zheng</name> </author> <category term="AI Infra" /> <summary> 前言 简述分布式通信相关知识栈（work with ChatGPT）。 总线/通信协议 PCIe   PCIe 1.0 PCIe 2.0 PCIe 3.0 PCIe 4.0 PCIe 5.0 PCIe 6.0 Year 2003 2007 2010 2017 2019 2021 Transfer per lane(Gbps) 2.5 5.0 8.0 16.0 32.0 64.0 x16 bandwidth(GB/s) ... </summary> </entry> <entry><title>LLMs存储</title><link href="https://www.johneyzheng.top//posts/LLMs%E5%AD%98%E5%82%A8/" rel="alternate" type="text/html" title="LLMs存储" /><published>2024-12-22T19:00:00+08:00</published> <updated>2024-12-22T19:00:00+08:00</updated> <id>https://www.johneyzheng.top//posts/LLMs%E5%AD%98%E5%82%A8/</id> <content src="https://www.johneyzheng.top//posts/LLMs%E5%AD%98%E5%82%A8/" /> <author> <name>Johney Zheng</name> </author> <category term="AI Infra" /> <summary> LLMs存储 前言 简述存储相关知识栈（work with ChatGPT）。 存储技术 多级存储 现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构，即L1 Cache、L2 Cache、L3 Cache的三级缓存结构。缓存级别越小，越靠近CPU，同样也意味着速度越快，但是对应的容量越少： 存储器存储空间大小：内存&amp;gt;L3&amp;gt;L2&amp;gt;L1&amp;gt;寄存器。 存储器速度快慢排序：寄存器&amp;gt;L1&amp;gt;L2&amp;gt;L3&amp;gt;内存。 从CPU到 CPU周期 执行时间（ns） ... </summary> </entry> </feed>
