[ { "title": "Modern-C++_工程实践", "url": "/posts/Modern-C++_%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/", "categories": "语言", "tags": "C++", "date": "2024-12-30 18:30:00 +0800", "snippet": "开发环境编译环境C++ 编译器是将 C++ 源代码转换为机器代码的工具。不同平台/系统有不同的C++编译器支持，几个主流的C++编译器如下： GCC(GNU Compiler Collection)： 跨平台，Linux常用，与GNU工具链集成，优化能力强，适合高性能计算和嵌入式开发。基础使用： Clang： 跨平台，原生支持macOS，编译速度快，与LLVM工具链集成，错误信息友好，适合开发和调试。 MSVC： Only Windows，与Visual Studio一起提供，集成性能分析工具，适合 Windows 应用开发。 基..." }, { "title": "Modern-C++_并发", "url": "/posts/Modern-C++_%E5%B9%B6%E5%8F%91/", "categories": "语言", "tags": "C++", "date": "2024-12-28 12:30:00 +0800", "snippet": "并发编程通俗地说，“并发”是指在一个时间段里有多个操作在同时进行，而“多线程”是实现并发的一种方式。多线程线程概念C++而言，线程就是一个能够独立运行的函数：auto f = []() // 定义一个lambda表达式{ cout &amp;lt;&amp;lt; &quot;thread id:&quot; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; endl;};thread t(f); // 启动一个线程：运行函数f多线程开发基于基础的thread线程类的简单例子：mutex out_lock;void fu..." }, { "title": "LLMs位置编码", "url": "/posts/LLMs%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/", "categories": "AI Infra, 算法篇", "tags": "LLMs", "date": "2024-12-25 13:00:00 +0800", "snippet": "前言在大规模语言模型（LLMs, Large Language Models）中，由于 Transformer 模型本身不具备天然的序列感知能力，所以需要引入位置编码的目的是帮助模型捕捉和理解输入序列中位置关系和顺序信息。绝对位置编码绝对位置编码将每个位置直接编码为唯一的固定向量。常见的绝对位置编码包括： 可学习位置编码 每个位置对应一个可训练向量，由模型学习其语义，如可学习的Posional Embedding。 固定正弦-余弦位置编码（Sinusoidal PE） Google在Attention Is All You Need提出，使用正弦和余弦..." }, { "title": "集群通信", "url": "/posts/%E9%9B%86%E7%BE%A4%E9%80%9A%E4%BF%A1/", "categories": "AI Infra", "tags": "硬件", "date": "2024-12-23 19:00:00 +0800", "snippet": "前言简述分布式通信相关知识栈（work with ChatGPT）。总线/通信协议PCIe   PCIe 1.0 PCIe 2.0 PCIe 3.0 PCIe 4.0 PCIe 5.0 PCIe 6.0 Year 2003 2007 2010 2017 2019 2021 Transfer per lane(Gbps) 2.5 5.0 8.0 16...." }, { "title": "LLMs存储", "url": "/posts/LLMs%E5%AD%98%E5%82%A8/", "categories": "AI Infra", "tags": "硬件", "date": "2024-12-22 19:00:00 +0800", "snippet": "LLMs存储前言简述存储相关知识栈（work with ChatGPT）。存储技术多级存储现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构，即L1 Cache、L2 Cache、L3 Cache的三级缓存结构。缓存级别越小，越靠近CPU，同样也意味着速度越快，但是对应的容量越少： 存储器存储空间大小：内存&amp;gt;L3&amp;gt;L2&amp;gt;L1&amp;gt;寄存器。 存储器速度快慢排序：寄存器&amp;gt;L1&amp;gt;L2&amp;gt;L3&amp;g..." }, { "title": "RLHF算法以及部署概述", "url": "/posts/RLHF%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2%E6%A6%82%E8%BF%B0/", "categories": "算法篇", "tags": "LLMs", "date": "2024-12-18 16:00:50 +0800", "snippet": "概述大型语言模型 (Large Language Model，LLM) 生成领域的新训练范式：RLHF (Reinforcement Learning from Human Feedback) ，即以强化学习方式依据人类反馈优化语言模型。RLHF 的意义在于能够结合人类的偏好与强化技术，对模型的输出进行优化，使模型更加符合人类期望，避免传统训练方法中问题，如：输出仅考虑语法的正确性和连贯性，但是不考虑合理性，会导致无意义回答以及牛头不对马嘴；输出没法满足各类规则/价值观的约束。RLHF通过reward model将人类反馈融入训练过程中，基于强化学习策略优化策略，使训练的结果更加符合用户..." }, { "title": "Modern-C++_STL_容器", "url": "/posts/Modern-C++_STL_%E5%AE%B9%E5%99%A8/", "categories": "语言", "tags": "C++", "date": "2024-12-09 14:30:00 +0800", "snippet": " 前置背景 序列容器 关联容器前置背景C++ STL（Standard Template Library） 是 C++ 标准库的重要组成部分，提供了丰富的数据结构和算法的实现。 STL 是基于泛型编程的，设计目标是高效、灵活和易用。它包含了通用的容器、算法、迭代器和函数对象。STL 容器用于存储和管理数据，有多种类型，适合不同的应用场景，可分为：序列容器、关联式容器、无序容器。容器都具有的一个基本特性：它保存元素采用的是“值”（value）语义，也就是说， 容器里存储的是元素的拷贝、副本，而不是引用 。所以元素很大，很多的时候，拷贝开销就会很大。一个解决方法式： 尽量为元素实现转移..." }, { "title": "Modern-C++_编程范式", "url": "/posts/Modern-C++_%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/", "categories": "语言", "tags": "C++", "date": "2024-12-09 12:30:00 +0800", "snippet": " 前置背景 面向过程编程(Procedural Programming) 面向对象编程(Object-Oriented Programming) 泛型编程(Generic Programming) 函数式编程(Functional Programming) 元编程(Meta Programming)前置背景C++支持多范式编程语言，允许开发者根据具体需求选择最佳的设计方法，具体包含以下五种： 编程范式 特点 应用场景 面向过程编程 基于函数和步骤，操作全局变量，简单直接。 小型程序、脚本型..." }, { "title": "Modern-C++_语言基础", "url": "/posts/Modern-C++_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/", "categories": "语言", "tags": "C++", "date": "2024-12-08 13:30:50 +0800", "snippet": " C++概述 生命周期和编程范式 数据类型与关键字 内存管理 基础概念 左值和右值 指针 C++类C++概述C++特点： C++ 是一门多范式的通用编程语言。C++支持”面向对象编程”、“泛型编程”、”函数式编程”： 面向对象：核心在于抽象和封装，通过高内聚低耦合的对象之间的通信协作来完成任务。 泛型编程：核心是“一切皆为类型”，通过模板而不是继承的方式来复用代码。 函数式编程：核心是“一切皆可调用”，通过一系列连续或者嵌套的函数调用来实现对数据的处理。生命周期和编程范式一个 C++ 程序从“诞生”到“消亡”，要经历这么几个阶段：编码（Coding）、预处理（Pre..." }, { "title": "LLM长文本优化策略", "url": "/posts/LLM%E9%95%BF%E6%96%87%E6%9C%AC%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/", "categories": "AI Infra", "tags": "LLMs", "date": "2024-12-04 18:46:50 +0800", "snippet": "LLM长文本优化策略长文本对LLM带来的挑战主要在于显存上的，核心原因是：原始Attention的计算过程中，中间变量的大小是$O(N^2)$增长的，可以通过FlashAttention的Tiling设计来降低中间变量显存为$O(\\frac {N ^ 2}{M})$，$KV_Cache$和FFN层的激活都为$O(N)$，所以核心思路是降低$sequence\\ length$，主要有以下两种方法：SP(序列并行，Sequence Parallism)，而序列并行最典型的思路便是：ULYSESS和Ring Attention。 Ulysess 核心思路是：Q/K/V矩阵按照N..." }, { "title": "Lora&amp;&amp;Multi-Lora", "url": "/posts/Lora&&Multi-Lora/", "categories": "算法篇", "tags": "LLMs", "date": "2024-11-29 18:28:50 +0800", "snippet": "Lora&amp;amp;&amp;amp;Multi-LoraPaperMULTILORA: DEMOCRATIZING LORA FOR BETTER MULTI-TASK LEARNINGS-LoRA: SERVING THOUSANDS OF CONCURRENT LORA ADAPTERSMotivationPEFT降低了大模型fine-tuning的硬件算力需求，比较常见如：LoRA；对于多任务PEFT的工作，之前的工作无法像LoRA一样和BaseModel参数做无缝集成。 Multi-LoRA在推理部署的问题的困境在于： 单个LoRA可以通过merge权重的方式，实现无开..." }, { "title": "Prefill Decode分离部署", "url": "/posts/Prefill_Decode%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2/", "categories": "算法篇", "tags": "LLMs", "date": "2024-11-25 18:34:50 +0800", "snippet": "Prefill Decode分离部署BackgroundPrefill和Decode两阶段的计算Pattern完全不一致：Prefill属于计算密集型任务，Decode属于IO密集型任务。Prefill和Decode混跑情况下，Prefill会打断Decode推理，无法更好的Batching，Decode的Batch数上限降低，几种混跑的策略如下：都存在一定问题： Request-level：Request之间queuing时间很长； Continuous：Prefill影响Decode的推理启动，导致TTFT时间过长； Mixed：混跑导致部分decode阶段时延延长。Motiv..." }, { "title": "SGLang-Prefix_Prompt_Cache设计", "url": "/posts/SGLang-Prefix_Prompt_Cache%E8%AE%BE%E8%AE%A1/", "categories": "算法篇", "tags": "LLMs", "date": "2024-11-19 18:26:50 +0800", "snippet": "SGLang-Prefix Prompt Cache设计PaperSGLang: Efficient Execution of Structured Language Model PrpgramsMotivation多轮对话中，由于Prompts存在大量相同前缀，因此 Prefix prompt cache 的复用就显得很重要：需要考虑：efficient prefix search,reuse,insertion,eviction已经对应的cache aware scheduing。Key PointsSGLang采用了 prefix tree 的数据结构来进行Cache的数据存储，基..." }, { "title": "MoEs算法&amp;&amp;部署概述", "url": "/posts/MoEs%E7%AE%97%E6%B3%95&&%E9%83%A8%E7%BD%B2%E6%A6%82%E8%BF%B0/", "categories": "AI Infra", "tags": "LLMs", "date": "2024-10-19 18:16:50 +0800", "snippet": "MoEs（Mixed Expert Models）MoEs最早由Switch Transformer提出,核心结构由稀疏MoE层和门控网络或者路由组成：\\[y = \\sum_{i=1}^{n} g_i(x) \\cdot f_i(x)\\]其中：$n$为专家数量；$g_i(x)$为门控网络对第$i$ 个专家的权重；$f_i(x)$ 是第$i$个专家对输入的输出。 稀疏 MoE 层: 这些层代替了传统 Transformer 模型中的前馈网络 (FFN) 层。MoE 层包含若干“专家”(例如 8 个)，每个专家本身是一个独立的神经网络。在实际应用中，这些专家通常是前馈网络 (F..." }, { "title": "PP&amp;&amp;TP LLMs部署", "url": "/posts/PP&&TP_LLMs%E9%83%A8%E7%BD%B2/", "categories": "AI Infra", "tags": "LLMs", "date": "2024-10-07 18:36:50 +0800", "snippet": "PP&amp;amp;&amp;amp;TP LLMs部署训练场景，并行策略有DP/TP/PP/EP等策略，也有不同并行策略的组合，以及Zero等OffLoad的策略。对于推理而言，最常用的是TP/PP策略。 TP最常用的策略主要在MLP/Self-Attention（num_head切分）进行切分，整体为：col-spllit-&amp;gt;row-split-&amp;gt;all-reduce。从参数量上看，单卡的权重为$\\frac {1}{TP}$，计算量上为$\\frac {1}{TP}$，激活值为$\\frac {1}{TP}$，但是由于输入为完整的seqlen，所以KV_Ca..." }, { "title": "Orca-Continuous Batching策略", "url": "/posts/Orca-Continuous_Batching%E7%AD%96%E7%95%A5/", "categories": "算法篇", "tags": "LLMs", "date": "2024-10-06 18:25:50 +0800", "snippet": "Orca-Continuous Batching策略PaperOrca: A Distributed Serving System for Transformer-Based Generative ModelsLLM推理主要氛围Prefill/Decode阶段，其中Prefill阶段为Compute Bound，Decode阶段为Memory-IO Bound，意味着需要充分利用显存的数据带宽。但是由于显存的限制，如A100-40GB而言，以13B模型为例，权重为26GB，其消耗单个Token的显存约为1MB（激活值/Cache等），则当Seq长度为2048时，仅能支持7 batch的推..." }, { "title": "LLMs图编译概述", "url": "/posts/LLMs%E5%9B%BE%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/", "categories": "AI Infra", "tags": "LLMs", "date": "2024-10-05 18:38:50 +0800", "snippet": "LLMs图编译概述图编译优化主要是围绕AI编译器来实现的，整体框架可参考：The Deep Learning Compiler: A Comprehensive Survey:LLMs图优化对于LLM来说，本身模型结构的变化不大，意味着图层面的优化策略是比较通用的，如：Quant算子的融合/PointWise算子融合/自定义融合算子等，所以常用的策略是复用PyTorch等框架的Compiler，自定义LLM的Compiler，如[RFC] A Graph Optimization System in vLLM using torch.compile中介绍的：基于TorchDynamo的F..." }, { "title": "大模型推理技术栈", "url": "/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF%E6%A0%88/", "categories": "算法部署", "tags": "模型部署, LLM", "date": "2024-10-04 19:00:00 +0800", "snippet": "前言影响LLM推理性能的因素有很多，包括但是不限于：模型配置、硬件类型、数据分布、优化算法、推理策略等。本位旨在综述各类技术点，后续会针对核心技术做详细展开。算法LLM参数建模大模型计算建模LLMs位置编码TransformerFlashAttention系列优化MoEs算法&amp;amp;&amp;amp;部署概述量化LLMs量化算法概述框架开源的LLM推理框架有TensorRT-LLM、FasterTransformer、TGI、vLLM、NanoFlow、SGLANG等，以VLLM为例简单介绍下推理框架：Serving策略Orca-Continuous Batching策略SGL..." }, { "title": "投机推理概述", "url": "/posts/%E6%8A%95%E6%9C%BA%E6%8E%A8%E7%90%86%E6%A6%82%E8%BF%B0/", "categories": "算法篇", "tags": "LLMs", "date": "2024-10-02 18:30:50 +0800", "snippet": "投机推理概述PaperMEDUSA: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads A Hitchhiker’s Guide to Speculative DecodingMotivationLLM的decoding阶段通常会受限于显存带宽(memory-bandwidth-bound)，因为decoding阶段单次仅生成单个token，导致计算效率偏低。提高decoding阶段的计算效率，其中一种方式便是：提高单次inference的计算强度/减少deocding的迭代次数。其设计思路是..." }, { "title": "大模型计算建模", "url": "/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%A1%E7%AE%97%E5%BB%BA%E6%A8%A1/", "categories": "算法部署", "tags": "LLMs, 模型部署", "date": "2024-01-05 15:30:50 +0800", "snippet": " 前言 参数量 计算量 显存占用 参考资料前言本文主要介绍Transformer类大模型训练/推理过程中的计算量/显存占用情况，因为对于大模型推理/训练而言，计算量决定了模型的训练/推理速度，显存占用情况决定了可供训练/推理的数据量（更大的显存能够并行跑更多的数据或者更长的序列）。 对于LLMs（Large Language Models）而言，模型结构整体趋同，整体可以分为：encoder-decoder和decoder-only两类。其中，GPT/GLM/LLaMA等主流对话类大模型都是基于decoder-only框架，且由于encoder/decoder在模型结构上差异不..." }, { "title": "GEMM算子优化", "url": "/posts/GEMM%E7%AE%97%E5%AD%90%E4%BC%98%E5%8C%96/", "categories": "AI Infra", "tags": "算子优化", "date": "2023-10-26 18:16:50 +0800", "snippet": "GEMM算子优化GEMM优化的核心在于： 提高Cache命中率，设计更好的数据排布(Tiling) 提高并行度，充分利用指令向量化和多核并行先看一个native的实现：void naive_row_major_sgemm(const float* A, const float* B, float* C, const int M, const int N, const int K) { for (int m = 0; m &amp;lt; M; ++m) { for (int n = 0; n &amp;lt; N..." }, { "title": "LLMs量化算法概述", "url": "/posts/LLMs%E9%87%8F%E5%8C%96%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/", "categories": "算法篇", "tags": "LLMs", "date": "2023-10-25 18:20:50 +0800", "snippet": "LLMs量化算法概述量化基础概念INT8 量化将模型的权重和激活值从 FP16/FP32 转换为 INT8 格式。最简单的方式是使用线性映射将浮点数范围映射到整数范围：\\[x_{int8} = \\text clip\\left(\\text{round}\\left(\\frac{x_{float} - z}{s}\\right), qmin, qmax\\right)\\] $z$ : 零点，用于偏移。 $s$ : 缩放因子，控制浮点和整数范围的映射。 $qmin,qmax$：对应量化的最大/最小值根据是否依赖“再训练”，可以分为两种方案： Post-training Quantiz..." }, { "title": "FlashAttention系列优化", "url": "/posts/FlashAttention%E7%B3%BB%E5%88%97%E4%BC%98%E5%8C%96/", "categories": "算法部署", "tags": "模型部署", "date": "2023-09-20 21:30:50 +0800", "snippet": "前言简单介绍各类AttentionScore优化算法。FlashAttentionV1FlashAttention于2022年6月由斯坦福大学、纽约州立大学研究者完成。 FlashAttention的核心思路是：通过重组Attention计算，能够对输入块进行分块，逐步执行softmax的reduction，避免了整个输入块的计算，从而减少了更少的内存访问（HBM），同时中间结果不需要输出都HBM。前置背景由于计算机多级缓存的设计：SRAM，HBM，DRAM的带宽逐渐变小，容量逐渐变大。 原始AttentionScore的IO复杂度为$Ω(N \\times d+N^2)$HBM访问，其中..." }, { "title": "算子编程模型", "url": "/posts/%E7%AE%97%E5%AD%90%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/", "categories": "AI Infra", "tags": "LLMs", "date": "2023-05-03 18:42:50 +0800", "snippet": "算子编程模型硬件特性当前深度学习应用硬件主要是GPU和各类XPU（AISC），GPU架构设计上的最大的特点是： 内存架构：GPU的片上Cache相对较小，且通常采用HBM等高带宽的存储，会设计多级存储方案 计算单元：GPU有强大的计算单元，且超配大量的多线程，专注大规模并行的计算任务。计算单元以GPU SM为单位，GPU单个时钟周期能支持多个Warp，A100为例，每个SM包含64个Warp，包含2048个线程。 软件特性GPU独特的硬件设计对应其SIMT编程特性，而传统的CPU或者XPU都是SIMD编程模型，其主要区别在于： SIMD采用一个..." }, { "title": "模型部署技术概览", "url": "/posts/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/", "categories": "算法部署", "tags": "模型部署", "date": "2023-04-09 13:30:50 +0800", "snippet": "前言开坑模型离线部署技术相关内容更新 简单梳理技术栈如下（需要持续更新）： 深度学习框架训练框架TorchPyTorch关键模块解读Tensorflow推理框架ONNXONNX的模型优化与量化细节TensorRTAI硬件AI模型部署硬件综述模型优化方案Transformer离线部署-GPU优化策略" }, { "title": "AI模型部署硬件综述", "url": "/posts/AI%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E7%A1%AC%E4%BB%B6%E7%BB%BC%E8%BF%B0/", "categories": "算法部署", "tags": "芯片，XPU，GPU", "date": "2022-11-13 21:30:50 +0800", "snippet": " 硬件篇 GPU NVIDIA 壁仞科技 XPU Google-TPU 晟腾 昆仑 寒武纪 软件篇 核心内容 参考硬件篇GPUGPU（Graphics Processing Unit），全称为图形处理器，是一种在个人电脑、工作站和一些移动设备上做图像和图形相关运算的微处理器。最早由NVIDIA公司在1999年8月发表Ge..." }, { "title": "Goolge-TPU论文解读", "url": "/posts/Goolge-TPU%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法部署", "tags": "芯片，TPU", "date": "2022-07-17 16:30:50 +0800", "snippet": " 文章背景 摘要 设计方案 性能结果 Discussion &amp;amp;&amp;amp; Conclusion 个人观点 参考文章背景In-Datacenter Performance Analysis of a Tensor Processing Unit 发表于ISCA2017，主要介绍Google TPU的架构。摘要Google从2013年发现，大量的DNNs网络用于语音识别搜索，对算力的需求为当前数据中心的一倍。而大量传递运行深入学习的网络需求对当时的CPU/GPU来说，成本较高。Tensor Processing Unit(TPU): Google自201..." }, { "title": "Transformer离线部署-GPU优化策略", "url": "/posts/Transformer%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2-GPU%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/", "categories": "算法部署", "tags": "NLP，模型部署", "date": "2022-05-14 16:27:50 +0800", "snippet": " 前言 模型结构分析 具体优化措施 参考资料前言本文主要介绍Transformer类网络在GPU设备上部署上的优化要点。 主要围绕Nvidia开源的FasterTransformer展开。模型结构分析标准的Transformer结构主要包括 Encoder 和 Decoder 两部分结构，具体结构分析可参考Transformer在CV领域的应用与部署：Encoder对应算子结构为：Decoder对应算子结构为：可以发现：Encoder/Decoder的基本结构还是一致的。其中主要算子（算力大头）为GEMM/Softmax算子；另外存在大量add bias/normalizatio..." }, { "title": "Bert:过去-现在-未来", "url": "/posts/Bert-%E8%BF%87%E5%8E%BB-%E7%8E%B0%E5%9C%A8-%E6%9C%AA%E6%9D%A5/", "categories": "算法篇", "tags": "NLP, 综述", "date": "2022-05-03 15:57:51 +0800", "snippet": " 前言 BERT发展历程 BERT算法细节 BERT后期发展 参考资料前言浅谈 BERT 系列网络，主要从三个维度介绍：发展历程、算法细节、后期发展。 背景知识： 自然语言处理（NLP）：其最终目的是理解复杂的语言/文字，主要任务包括： 序列标注：如中文分词、词性标注、命名实体识别、语义角色标注等 分类任务：文本分类、情感分析等 句子关系判断：如QA，自然语言推理等 生成式任务：机器翻译、文本摘要、写诗造句等。BERT发展历程NLP本质是对语言/文字进行合理的数学表达，方便机器理解，其核心问题是怎么讲将语言文字转化为合理的“数学空间表示”。从最简单的one-hot编码到..." }, { "title": "设计模式-设计原则", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 22:10:50 +0800", "snippet": " 基本介绍 SOLID原则 单一职责原则 开放封闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 其他原则 LoD原则 KISS原则 DRY原则 YAGBI原则 Rule Of Three原则 CQS原则 基本介绍设计模式可以认为是面向对象编程的编程思想，设计原则即这些编程思想的指导总纲。 SOLID是面向对象设计（OOD）的五大基本原则的首字母缩写：S-单一职责原则；O-开放封闭原则；L-里氏替换原则；I-接口隔离原则；D-依赖倒置原..." }, { "title": "设计模式-MVC模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVC%E6%A8%A1%E5%BC%8F/", "categories": "", "tags": "Python, 设计模式", "date": "2022-02-02 20:10:50 +0800", "snippet": " 概念解析 实例分析概念解析MVC模式为软件工程中的一种常用软件架构模式，但是并没有一个标准的定义，通常来将其将软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 M：负责数据存储 V：负责数据显示 C：负责与用户的交互逻辑。MVC模式类图如下：优点： 低耦合性，软件分层，可以独立发展，方便团队合作，快速开发 高重用性和可适用性：适用于各类场景名，如Web端、移动端、桌面端等 快速开发、部署，现有很多现成框架都是基于MVC模式的应用场景： 互联网场景应用广泛，如：前后端的分离，甚至前后端内部的各自分离 基于MVC的延伸扩展..." }, { "title": "设计模式-回调机制", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 18:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析回调机制，回调指的是：把函数作为参数，传递给另一个函数，延迟到另一个函数的某个时刻执行的过程为回调，本质上是函数式的一种体现。如果语言只支持面向对象编程，则可以使用策略模式来实现回调机制。 优点： 避免重复代码 增强代码可维护性 有更多定制功能缺点： 避免“回调地狱”：多重的回调函数调用常用场景： 第三方库和框架中 异步执行（例如读文件、发送HTTP请求等）设计模板回调机制的代码框架如下：def callback(*args, **kwargs): &quot;&quot;&quot;回调函数&quot;&quot;&quot..." }, { "title": "设计模式-对象池技术", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 16:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析对象池技术，指的是设计一个集合，其中包含了初始化且可以使用的对象，当需要使用相关对象时，直接从中获取，且使用完后需要归还。与前置“享元模式”的区别在于，享元模式没有“占用”的概念，享元对象都是共享的，而对象池中的对象则在“借出”期间是被独占的，可以修改对象的部分属性，而享元独享的属性通常无法被更改。 对象池的两个核心对象： 要进行的池化对象：通常是创建和销毁比较耗时，或者本身比较占内存的对象 对象池：对象集合，或者管理器，用于管理对象的借用、归还其优点在于： 实现了对象的重复使用，减少内存占用，提升程序性能缺点在于： 借用和归还操作需要..." }, { "title": "设计模式-过滤器模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 14:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析过滤器模式，即根据某种规则，从一组对象中过滤掉一些不符合要求的对象的过程。主要包含三个角色： 过滤的目标（Target）：即要被过滤的对象 过滤器（Filter）：负责过滤不需要的对象，一般一个规则对应一个类 过滤器类（FilterChain）：过滤器集合，负责管理和维护过滤器。过滤器模式类图如下：优点： 将对象的过滤、校验逻辑抽离出来，降低系统的复杂度 过滤规则可实现重复利用缺点： 性能低，每个过滤器需要对每个元素进行遍历：如n个元素，m个过滤器，则复杂度为O（mn）常用场景： 敏感词过滤/舆情监测 对象列表进行检验、审查或预..." }, { "title": "设计模式-解释模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 12:10:50 +0800", "snippet": " 概念解析 实例分析概念解析解释模式，是一种难度较高的设计模式：定义一个语言/文法的一种表示，并定义一个解释器，该解释器使用该文法来解释语言中的句子。 解释模式通常用于设计一个简单的语法分析工具，最显著的优点是：拓展性好，修改相应语法规则，需要修改对应模块语法即可。 解释模式类图如下：实例分析场景分析：设计一个简单的加减法计算器：如输入a/b/c的值，计算公式为a+b+c的数值：from abc import ABCMeta, abstractmethodclass Expression(metaclass=ABCMeta): &quot;&quot;&quot;抽象表达式&q..." }, { "title": "设计模式-桥接模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 10:10:50 +0800", "snippet": " 概念解析 实例分析概念解析桥接模式，与策略模式类似，只是桥接模式侧重于软件结构，策略模式侧重于对象行为。其功能是：将抽象和实现解耦，使得可以独立地变化。 桥接模式类图如下：使用场景主要是： 产品可以进行划分为多个分类和组合，即多个独立变化的维度，每个维度都希望独立进行扩展 对于由于继承/多重继承导致系统类数目急剧增加的系统，可以改用桥接模式来实现实例分析场景分析：几何分类的设计：形状有矩形、椭圆形等，颜色有红色、绿色等；如果采用一般继承，如图形-&amp;gt;矩形-&amp;gt;红色矩形，这样添加更多颜色/形状的时候，类图会变得很臃肿。采用桥接模式，代码如下：from ab..." }, { "title": "设计模式-模板模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-02 08:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析模板模式，指的是定义一个操作中的算法框架，而将算法中用到的某些具体步骤放到子类中实现，使得子类在不改变算法结构的情况下重新定义该算法的某些特定步骤。其实模板模式本质上只是利用了对象的继承机制。 基本适用场景：公共方法提取复用，避免代码重复；或者希望通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。设计模板模板模式的框架模型如下：from abc import ABCMeta, abstractmethodclass Template(metaclass=ABCMeta): &quot;&quot;&quot;模板类（抽..." }, { "title": "设计模式-访问模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 16:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析访问模式，指的是封装一些作用于某种数据结构中各个元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作。该模式主要存在三个角色： 访问者（Visitor）：负责对数据节点进行访问和操作 数据节点（DataNode）：被操作的数据对象 对象结构（ObjectStructure）：数据结构的管理类，也是数据对象的容器访问模式类图如下：优点： 数据和操作分离，降低了耦合度，职责清晰 增加新的访问操作很方便，符合开闭原则，且不需要更改数据结构缺点： 元素类添加很困难，元素类的添加会影响访问者类的具体操作，不符合开闭原则 一定程..." }, { "title": "设计模式-享元模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 14:10:50 +0800", "snippet": " 概念解析 实例分析概念解析享元模式，该模式能够支持大量细粒度对象的复用。所谓细粒度对象，指的是为基本的轻量级对象，享元模式能够实现共享细粒度对象从而节约资源成本。对应的享元对象两个关键属性： 内部状态：存储在享元对象内部并且不会随环境改变而改变的状态 外部状态：随环境改变而改变，不可以共享的状态，该状态在创建或者使用过程中引入享元模式的两个主要角色为： 享元对象：被共享的轻量级对象 享元工厂：享元模式的核心角色：负责创建和管理享元对象。四个设计要点： 享元对象需要为轻量级、细粒度对象 需要区分享元对象的内部状态、外部状态 享元对象内部状态是不可改变的 使用对象通过享..." }, { "title": "设计模式-命令模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 13:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析命令模式，能够讲一个请求封装成一个对象，从而能够使用不同的请求把客户端参数化，对请求进行排队或者记录请求日志，可以提供命令的撤销和恢复功能。其核心是将具体的命令和对应的接受者相关联，使得调用方不用关心具体的行动执行者以及如何执行，只要发送正确的命令，就能准确无误地完成相应的任务。命令模式的三个核心角色： 命令（Command）：要完成的任务，或要执行的动作，为命令模式的核心角色 接受者（Receiver）：任务的具体实施方，或者行动的真实执行者 调度者（Invoker）：接收任务并发送命令，对接用户需求并执行内部命令，负责外部用户与内部命..." }, { "title": "设计模式-工厂模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 12:10:50 +0800", "snippet": " 概念解析 实例分析概念解析工厂模式，其目的是建立通用的”工厂类”，得到不同类的实例。工厂模式包含三种模式，从简单到高级不断升级：简单工厂模式、工厂方法模式、抽象工厂模式。 简单工厂模式：能够根据输入参数不同创建不同类的实例：定义一个创建对象的接口，通过参数来决定创建哪个类的实例。 工厂方法模式：定义一个创建对象的接口：让子类来决定创建哪个类的实例，工厂方法使一个类的实例化延迟到其子类 抽象工厂模式：提供一个创建一系列相关和相互依赖的对象的接口，而无须指定它们的具体类 其三者之间的递进关系为： 简单工厂使用简单，根据不同..." }, { "title": "设计模式-策略模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 10:10:50 +0800", "snippet": " 概念解析 实例分析概念解析策略模式，在于将每个算法都封装起来，并且使它们之间可以相互替换，策略模式可以使算法可以独立使用它的用户而发生变化。其设计模式中的三个角色在于： 上下文环境(Context):起着承上启下的封装作用，屏蔽上层应用对策略（算法）的直接访问，封装可能存在的变化 策略的抽象（Strategy）：策略（算法）的抽象类，定义统一 的接口，规定每个子类型需要实现的方法 具备的策略：策略的具体实现者，可以有多个不同的算法以及规则实现策略模式类图如下：策略模式的优点： 算法/规则可以自由切换 避免使用多重条件进行判断 方便拓展和增加新的算法（规则）缺点： 所有..." }, { "title": "设计模式-适配模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 09:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析适配模式，指的是：将一个类的接口变成客户端所期望的另一种接口，从而使得原本因接口不匹配而无法一起工作的两个类能够一起工作。即适配模式的作用是： 接口转换，将原有的接口（或方法）转换成另一个接口 用新的接口包装一个已有的类 匹配一个老的组件到一个新的接口适配模式主要存在三个角色： 目标（Target）：即你期望的目标接口，要转换成的接口 源对象（Adaptee）：即要转换的角色，要把谁转换为目标角色 适配器（Adapter）：适配模式的核心角色，负责把源对象转换和包装成目标对象适配模式类图如下：其优点在于： 可以将两个无关联的类一起..." }, { "title": "设计模式-备忘模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-02-01 09:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析备忘模式，指的是在不破坏内部结构的前提下捕获一个对象的内部状态，这样便可将该对象恢复到原先的保持状态。备忘模式的最大功能是备份，其主要的三个角色： 发起人（Originator）：需要进行备份的对象 备忘录（Mementor）：备份的状态，即一个备份的存档 备忘管理者（Caretaker）：备份存档的管理者，由它负责与发起人的交互备忘模式类图如下：备忘模式的优点： 能够恢复之前的状态 实现了信息的封装，用户不需要关心状态的保存细节常用场景： 存档/快照场景 撤销/恢复功能 回滚操作设计模板备忘模式的代码框架如下：from cop..." }, { "title": "设计模式-代理模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-31 17:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析代理模式，指的是对象完成某项动作或任务，是通过对另一个对象的引用来完成的，即“为其他对象提供一个代理以控制这个对象的访问”。其英文称为”Proxy”或”Surrogate”，其核心思想为： 使用一个额外的间接层来支持分散的、可控的、智能的访问 增加一个包装和委托来保护真正的组件，以避免过度复杂设计过程中包含三个核心角色： Subject：定义操作、活动、任务的接口类 RealSubject：真正完成操作、活动、任务的具体类 ProxySubject：代替真实主题完成操作、活动、任务的代理类代理模式类图如下：优点： 代理模式能够协调调..." }, { "title": "设计模式-外观模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-31 14:10:50 +0800", "snippet": " 概念解析 实例分析概念解析外观模式，是最简单也是最常用的模式，存在两个角色： 外观角色（Facade）：为子系统封装统一的对外接口，如同子系统的门面。该类不负责具体的业务逻辑，具体业务逻辑则由子系统完成； 子系统（SubSystem）：由多个类组成的具有特定功能的子系统：可以是第三方库，也可以是自己的基础库，还可以是子服务，为整个系统提供特定的功能或服务。外观模式类图如下：其优点是： 实现了子系统和客户端的松耦合关系，使得子系统的变化不会影响其上层的调用关系； 简化类客户端对子系统的使用难度：客户端不需要了解子系统的具体实现方式，而只需要和外观角色进行交互即可； 能够为不..." }, { "title": "设计模式-迭代模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-31 13:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析迭代模式，也被称为所谓迭代器模式，其核心是实现一个迭代器，其基本两个方法： 获取当前所指向的元素：current() 将指针移至下一个元素：next()迭代器的意义在于提供了一个顺序访问容器对象各个元素的方法，能够不暴露对象的内部实现。Python本身实现了迭代器方式。其设计要点为： 需要了解数据结构以及可能的层次结构 需要根据访问要实现的功能实现具体的功能，如：next()/previous()/current()等其优点在于： 迭代器模式能够将存储数据和便利数据两项职责分离 简化了聚合数据的访问方式 可支持多种不同的访问方式其..." }, { "title": "设计模式-组合模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-31 10:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析组合模式，指的是：将对象组合成树形结构以表示“整体-部分”的层次结构，组合使得用户对单个对象和复合对象的使用具备一致性。其设计要点为： 理清部分与整体的关系，了解对象的组成结构 组合模式为一种具有层次关系的树形结构，不能再分的叶子节点为具体的组件，即最小的逻辑单元；具有子节点（由多个子组件组成）被称为复合组件，即组合对象；对于复合组件和子组件两者，用户对两者的使用具备一致性。组合模式的类图如下：组合模式的优点在于： 调用简单，组合对象可以像一般对象一样使用 组合对象可以自由地增加、删除组件，可灵活地组合不同对象缺点在于： 层次结构太深..." }, { "title": "设计模式-构建模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-31 09:10:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析构建模式，指的是将复杂对象的构建过程和它的表现分离，使得不同的构建过程可以获取（创建）不同的表现。构建模式的三个主要角色： 产品（Product）：要构建的对象 构建者（Builder）：构建模式的核心类，负责产品的构建过程 指挥者（BuilderManager）：构建的管理类，负责管理每一种产品的创建数量和创建顺序构建模式类图如下：构建模式的优点在于： 将产品的创建过程与产品本身分离，让使用方（调用者）可以用不同的创建过程创建不同的产品/对象 将对象的创建过程分离出来，精确控制复杂对象的创建 BuilderManager为构建模式..." }, { "title": "设计模式-装饰模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-16 13:50:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析装饰模式，指的是动态地给一个对象增加一些额外的职责，就拓展对象来说，装饰模式比生成子类的方式更加灵活。功能上看，和Python自带的装饰器类似，但是装饰模式更倾向于从设计模式的角度，通常是修饰某个类的指定方法（装饰器用法更多更杂）。其设计的要点是： 可以灵活地进行对象的职责添加和拓展功能 可增加任意多个装饰 装饰的顺序不一样，可能产生不同的效果其类图如下： 设计模板装饰模式通常是设计一个装饰器，Python而言，通常有两种：修饰函数/修饰类。具体可参见：Python-常用装饰器。实例分析简单样例：给Person类添加 wear 接口，能够..." }, { "title": "设计模式-职责模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-16 13:20:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析职责模式，也被称为“职责链模式”，其设计目的是为了避免请求发送者和接受者耦合在一起，而是将接受对象连接，形成职责链，知道有对象处理。客户不需要知道请求处理者的明确信息和处理的具体逻辑，需要进行请求发送即可。其设计要点如下： 需要明确请求者和请求内容。 明确有哪些责任人并对责任人进行抽象 责任人可以自由组合其优点是： 降低耦合度，请求的接受者和发送者解耦 简化对象：对象不需要知道职责链结构 职责传递更灵活 增加新的处理类很方便其缺点是： 无法保证请求一定被接受 可能造成循环调用类图如下： 设计模板职责模式代码样例如下，关键在于 ..." }, { "title": "设计模式-单例模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-16 13:10:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析顾名思义，单例模式，指的便是：希望类只能有一个实例，通常应用于一些全局管理器。设计模板以下展示三种不同的单例模式的实现方式：class Singleton1(object): &quot;单例实现方式一：基本实现&quot; __instance = None __isFirstInit = False def __new__(cls, name): if not cls.__instance: Singleton1.__instance = super().__new__(cls) ..." }, { "title": "设计模式-克隆模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%8B%E9%9A%86%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-16 12:50:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析克隆模式的核心是：通过拷贝自身属性来创建一个新对象，核心方法就是 clone 方法，包括两个步骤： 分配一块新的内存空间给新的对象 拷贝父本对象的所有属性克隆模式的特点是： 通过内存拷贝的方式进行复制，比new方式创建对象性能更好 可以选用设计浅拷贝和深拷贝 通过clone方式创建，不会执行类的初始化 __init__ 函数设计模板克隆模式比较简单，简单框架如下：from copy import copy, deepcopyclass Clone: &quot;基类&quot; def clone(self): ..." }, { "title": "设计模式-中介模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2022-01-15 08:50:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析中介模式指的是：用一个中介对象来封装一系列的对象交互，中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变地改变它们之间的交互。中介模式主要有三个角色： 交互对象（InteractiveObject）: 要进行交互的一系列对象 中介者（Mediator）：负责协调各个对象之间的交互 具体中介者（Mediator）：中介的具体实现中介模式的优点是：简化了对象之间的交互，将多个调用者和多个实现者这件多对多的交互关系转化为一对多的关系：易于理解、维护和扩展，大大减少了多个对象之间的相互交叉引用的情况。其缺点是：中介者承接了..." }, { "title": "Python-常用装饰器", "url": "/posts/Python-%E5%B8%B8%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8/", "categories": "语言", "tags": "Python", "date": "2021-12-12 12:35:47 +0800", "snippet": " 简单聊聊装饰器 常用装饰器介绍 Python自带的 装饰器 用法： 常用的一些自定义 *装饰器*： 部分参考资料简单聊聊装饰器装饰器是 Python 提供的语法糖：通过 @ 的方式构造，传入函数，装饰器返回的是内部函数 wrapper() ，该函数本身不会改变传入的函数，但是会添加一些额外的功能，常见的如：统计运行时间、检查合法输入、提供缓存等。详情可参照：Python-闭包+装饰器。本文主要介绍一些常用的装饰器：让自己的代码看上去更简洁高效吧。常用装饰器介绍Python自带的 装饰器 用法： @lru_cache 基于缓存能够加..." }, { "title": "设计模式-UML", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/", "categories": "语言", "tags": "Python, 设计模式", "date": "2021-12-11 23:10:50 +0800", "snippet": " 前言 UML类图前言UML 为 Unified Modeling Language 的缩写，即“统一建模语言”。其作用在于建立了一套整图组成的标准化建模语言，用于帮助系统开发人员阐明、设计和构建软件系统。UML图一般分为两组，一组称为结构性图，如类图、组件图、部署图等；一组称为行为性图，如用例图、活动图、序列图等。其中应用最为广泛的便是类图了，常用于系统软件设计。UML类图UML类图最为常见的几种关系有：泛化（Generalization）、实现（Realization）、组合（Composition）、聚合（Aggregation）、关联（Association）、依赖（Depe..." }, { "title": "Transformer在CV领域的应用与部署", "url": "/posts/Transformer%E5%9C%A8CV%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E9%83%A8%E7%BD%B2/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-11-07 16:57:51 +0800", "snippet": " 前言 Transformer介绍 Transformer for CV Transformer类网络部署 参考资料前言浅谈 Transformer 原理以及基本应用以及模型优化的一些思考。Transformer介绍Transformer 最早出自Google 2017年发布的论文：Attention is all you need。Transformer 结构提出在于完全摈弃了传统的循环的”encoder-decoder”结构，取而代之的是采用”self-attention”结构。传统的循环结构的问题在于：结构是串行的，即下个结构的输入依赖于上层结构的输出，该固有属性的问题是..." }, { "title": "Python-单元测试", "url": "/posts/Python-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/", "categories": "语言", "tags": "Python", "date": "2021-10-17 00:03:47 +0800", "snippet": " 前言 基本使用（unittest） mock patch 高质量单元测试前言单元测试(unit test)，对于程序规范开发，尤其是测试驱动开发(TDD)，非常重要。单元测试，其核心是：编写测试来验证某一个模块的功能正确性，一般会指定输入，验证输出是否符合预期。 对Python而言，常用的测试相关库有：unitest/nose/pytest等。这里重点介绍下unitest，为Python内置库，模仿PyUnit写的。基本使用（unittest）简单看下 unittest 库的简单使用：import unittest# 将要被测试的排序函数def sort(arr): l..." }, { "title": "Python-上下文管理器", "url": "/posts/Python-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/", "categories": "语言", "tags": "Python", "date": "2021-10-16 23:03:47 +0800", "snippet": " 前言 基于类的上下文管理器 基于生成器的上下文管理器前言上下文管理器（context manager），其作用能够帮助自动分配并且释放资源，其中最典型的便是 with 语句：for x in range(10000000): with open(&#39;test.txt&#39;, &#39;w&#39;) as f: f.write(&#39;hello&#39;)其等效于：f = open(&#39;test.txt&#39;, &#39;w&#39;)try: f.write(&#39;hello&#39;)finally: f.close..." }, { "title": "Python-垃圾回收", "url": "/posts/Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/", "categories": "语言", "tags": "Python", "date": "2021-10-07 16:03:47 +0800", "snippet": " 前言 垃圾回收方法 内存泄漏调试前言垃圾回收对于每一门语言来说都是至关重要的，其核心功能是进行“内存管理”，防止”内存泄漏“，所谓”内存泄漏”指的是：程序未能释放已不再使用的内存，通常是因为程序设计上的问题，导致程序失去了对使用过的内存的控制，导致了内存的浪费。 本文重点梳理下 Python 下的垃圾回收机制。垃圾回收方法Python 中最常用的是 计数引用 的机制： Python 中一切都是对象，所有的变量都是对象的引用。因此，最直观的想法，便是通过对象的引用计数来进行垃圾回收： 当一个对象的引用计数为0时，说明这个对象不可达，需要被回收 简单用例如下：import sysa ..." }, { "title": "Python-闭包+装饰器", "url": "/posts/Python-%E9%97%AD%E5%8C%85+%E8%A3%85%E9%A5%B0%E5%99%A8/", "categories": "语言", "tags": "Python", "date": "2021-10-07 14:03:47 +0800", "snippet": " 前言 闭包 装饰器前言本文介绍下 闭包(closure) , 装饰器(decorator) 合理使用 闭包 可以简化程序复杂度，提高可读性。 闭包常常和 装饰器 一起使用，能很大提高程序的可读性和复用性。闭包所谓闭包，指的是：函数定义中存在“嵌套函数”场景，且外部函数返回的是一个函数。返回的函数可以赋给变量，在后续被调用。下面举个计算指数的用例：def nth_power(exponent): def exponent_of(base): return base ** exponent return exponent_of # 返回值是exponent_..." }, { "title": "Python-metaclass", "url": "/posts/Python-metaclass/", "categories": "语言", "tags": "Python", "date": "2021-10-07 00:03:47 +0800", "snippet": " 前言 metaclass概念介绍 案例介绍前言本文重点介绍下 metaclass 的用法， metaclass 通常使用很少，引用 Tim Peters 的话：主要原因还是: 涉及 metaclass 的修改，可能会对正常的Python类型模型进行修改，所以可能对整个代码库造成风险，通常在开发框架层面的Python库中会使用，但在应用层很少会用到。metaclass概念介绍metaclass 核心操作是“动态改变类的行为”。因为在 Python 语言中，类其实也是对象，所有类也是基于 Python 内置类 type 类的实例，这里用户自定义类本质上也是 type 类的 __cal..." }, { "title": "设计模式总结（Python）", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-Python/", "categories": "语言", "tags": "Python, 设计模式", "date": "2021-10-06 16:16:22 +0800", "snippet": " 前言 UML介绍 监听模式 状态模式 中介模式 装饰模式 单例模式 克隆模式 职责模式 代理模式 外观模式 迭代模式 组合模式 构建模式 适配模式 策略模式 工厂模式 命令模式 备忘模式 享元模式 访问模式 模板模式 桥接模式 解释模式 过滤器模式 对象池技术 回调机制 MVC模式 设计原则前言#finished on 2022/02/02 整理设计模式结束～受教于“罗剑锋”老师三句格言： 任何人都能写出机器能看懂的代码，但只有优秀的程序员才能写出人能看懂的代码。 有两种写程序的方式：一种是把代码写得非常复杂，以至于“看不出..." }, { "title": "设计模式-监听模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2021-10-06 15:50:57 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析监听模式（观察者模式），核心是设计监听者和被观察者，当被观察者对象在状态或者内容数据发生变化时，能够通知所有的监听者对象（被动/主动）相应的变化，然后监听者对象能够做出相应的反应。其本身属于“一对多”的关系，也有很多名称：“发布/订阅模式”、“模型/视图模式”、“源/监听器模式”等。监听者模式的类图如下： 上图中， Subject 为被观察者抽象类， Observer 为监听者抽象类， ConcreteObserver 为监听者具体实现， ConcreteSubject 为被观察者具体实现。其中被观察者的核心方法是：添加监听者、移除监听者、通..." }, { "title": "设计模式-状态模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/", "categories": "语言", "tags": "Python, 设计模式", "date": "2021-10-06 15:48:50 +0800", "snippet": " 概念解析 设计模板 实例分析概念解析所谓 状态模式 ：允许一个对象在其内部发生改变时改变其行为，使这个对象看上去就像改变了它的类型一样。其适用于的场景： 对象行为取决于其状态，且对象的状态是可变的 存在很多对象场景，本身都符合1. 场景，分散为很多多分支逻辑代码状态模式的核心是设计：控制状态切换的上下文环境类，和描述状态的状态类（管理影响状态变化的各类信息）。其类图如下： Context 基类的核心操作做对状态进行转换， State 基类需要描述状态匹配的方法以及对象的行为。 状态模式 下需要注意的是： 每个状态应当设计为 单例模式 将所有和状态相关的行为放到单个类中（状..." }, { "title": "《流畅的Python》后记", "url": "/posts/%E6%B5%81%E7%95%85%E7%9A%84Python-%E5%90%8E%E8%AE%B0/", "categories": "语言", "tags": "Python, 读书笔记", "date": "2021-10-06 12:41:00 +0800", "snippet": " 前言 基本数据结构 函数装饰器和闭包 对象引用、可变性和垃圾回收 抽象基类 可迭代的对象、迭代器和生成器 并发细节 元编程前言《流畅的Python》读书心得，结合之前自己的积累，记录一些Python的关键要点。同时，感觉之前的博客/整理，更多倾向于自我记录，缺少了整体思维脉络的梳理与拓展，之后会尽量加入一些自己个人的感悟和背景的补充。首先，简单谈谈Python，自己比较熟悉的语言主要是C++和Python。尤其是工作之后，大部分时间，Python都是我的主要工作语言。这当然和个人的工作领域有关，Python的优点之一是适合数据分析领域，因此被广泛应用于人工智能、机器学习..." }, { "title": "2D_Detection-超参", "url": "/posts/2D_Detection-%E8%B6%85%E5%8F%82/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-10-04 10:02:51 +0800", "snippet": " 前言 详细介绍 learning rate策略 optimizer postive &amp;amp;&amp;amp; negative assinger 前言本文重点介绍深度学习中一些基本参数设置，以及常用的技巧。详细介绍learning rate策略learning rate 的作用是能够在随着深度学习模型逐渐收敛的过程中，控制模型权重更新的“步长”，进一步提升模型精度，基于梯度进行权重更新的基本过程如下：\\[weight_{new} = weight_{existing} - learning\\_rate * func(gra..." }, { "title": "2D_Detection-通用检测Tricks", "url": "/posts/2D_Detection-%E9%80%9A%E7%94%A8%E6%A3%80%E6%B5%8BTricks/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-10-03 14:09:38 +0800", "snippet": " 前言 详细介绍 样本不均衡 常见Hard Example策略 Focal Loss及其变种 小物体检测 如何融合多尺度特征 脱离bbox看待问题检测 密集遮挡场景 nms引发的问题 如何让定框变得准确？ 怎么解决高度重叠的场景？ 前言通常来说，单一检测模型往往无法覆盖所有的场景；对..." }, { "title": "2D_Detection-Loss", "url": "/posts/2D_Detection-Loss/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-10-01 15:44:56 +0800", "snippet": " 前言 详细介绍 分类任务Loss Cross Entropy Loss KL散度 Hinge Loss 指数损失 回归任务Loss MAE Loss MSE Loss Smooth L1 Loss Huber Loss 检测任务Loss Focal Loss QFo..." }, { "title": "ONNX的模型优化与量化细节", "url": "/posts/ONNX%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E4%B8%8E%E9%87%8F%E5%8C%96%E7%BB%86%E8%8A%82/", "categories": "算法部署", "tags": "离线推理", "date": "2021-09-21 17:18:48 +0800", "snippet": "ONNX的模型优化与量化细节ONNX基本介绍 什么是ONNX？ ONNX全称为 Open Neural Network Exchange，是一种与框架无关的模型表达式。ONNX的规范及代码主要由微软，亚马逊 ，Facebook 和 IBM 等公司共同开发，以开放源代码的方式托管在Github上。目前官方支持加载ONNX模型并进行推理的深度学习框架有： Caffe2, PyTorch, MXNet，ML.NET，TensorRT 和 Microsoft CNTK，并且 TensorFlow 也非官方的支持ONNX。 ONNX的数据格式是怎么样的？ ONN..." }, { "title": "2D_Detection-模型加速(工程篇)", "url": "/posts/2D_Detection-%E6%A8%A1%E5%9E%8B%E5%8A%A0%E9%80%9F(%E5%B7%A5%E7%A8%8B%E7%AF%87)/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-09-20 17:18:48 +0800", "snippet": " 前言 详细介绍 工程加速 Distillation MultiTask 量化 算子/图融合 前言深度学习网络的加速问题包含两部分内容：网络结构侧的加速和工程侧的加速。工程层面的加速，网络结构基本是不变的，更多从网络推理角度探讨如何在不损失精度（或者损失较小）的前提下，提高模型的推理速度（吞吐率）。详细介绍工程加速DistillationDistillation是一项常用于模型加速的技术。Ditillation通常包含两个模型:Teacher..." }, { "title": "2D_Detection-模型加速(网络篇)", "url": "/posts/2D_Detection-%E6%A8%A1%E5%9E%8B%E5%8A%A0%E9%80%9F(%E7%BD%91%E7%BB%9C%E7%AF%87)/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-09-04 15:34:34 +0800", "snippet": " 前言 详细介绍 网络加速 SqueezeNet MobileNet ShuffleNet OneNet 网络剪枝 前言深度学习网络的加速问题包含两部分内容：网络结构侧的加速和工程侧的加速。网络层面的加速主要从网络结构上进行优化，关注点在于网络的计算量和参数量上。详细介绍网络加速对于图像检测领域来说，网络侧速度的瓶颈更多还是在于其Backbone上，所以很多网络加速Tricks都是基于Backbone开展的，以下介绍三种常用..." }, { "title": "2D_Detection-经典检测框架介绍", "url": "/posts/2D_Detection-%E7%BB%8F%E5%85%B8%E6%A3%80%E6%B5%8B%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-08-29 15:47:39 +0800", "snippet": " 前言 Two Stage算法 RCNN系列 Faster-RCNN总览 基于Faster-RCNN改进算法 One Stage算法 SSD YOLO YOLO V1 YOLO V2 YOLO V3 YOLO V4 &amp;amp;&amp;amp; YOLO V5 Anchor Free算法 FC..." }, { "title": "数据结构与算法(Python)-优先队列&amp;&amp;最大(小)堆", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(Python)-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&&%E6%9C%80%E5%A4%A7(%E5%B0%8F)%E5%A0%86/", "categories": "数据结构与算法", "tags": "LeetCode, Python", "date": "2021-08-22 12:51:38 +0800", "snippet": " 前言 数据结构介绍 优先队列 最大（小）堆 实战解析前言Python自带的库包含了挺多常用的数据结构，巧妙地利用这些自带的数据结构，能够大大提高解题/实现的效率。下面介绍两种常用的数据结构： 优先队列 最大（小）堆数据结构介绍优先队列 简单介绍 所谓优先队列，其含义是队列中的每个元素都有各自的优先级。其中得到最高优先级的元素，其时间复杂度为O（1）。 应用场景 常用于求区域内最大最小值的问题；采用优先队列通常可以得到O（n）的解法，带有一定的技巧性 简单实现 可以基于 collec..." }, { "title": "Jekyll博客拓展--支持Latex&amp;&amp;图片加速", "url": "/posts/Jekyll%E5%8D%9A%E5%AE%A2%E6%8B%93%E5%B1%95-%E6%94%AF%E6%8C%81Latex&&%E5%9B%BE%E7%89%87%E5%8A%A0%E9%80%9F/", "categories": "环境配置", "tags": "博客, Jekyll", "date": "2021-08-21 12:19:24 +0800", "snippet": " 前言 Mathjax支持 图床迁移 构建Github仓 获取CDN转换规则 通过PicGo上传图片 直接通过git自动上传 前言对前文博客构建的扩展支持：基于Jekyll搭建博客Mathjax支持添加 mathjax 支持包括两个部分：添加 mathjax 依赖；添加 mathjax 开关。 添加 _includes/mathjax_support.html :&amp;lt;div id=&quot;mathjax&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script ..." }, { "title": "2D_Detection-Backbone", "url": "/posts/2D_Detection-Backbone/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-08-15 14:52:51 +0800", "snippet": " 前言 VGG-Net Inception Inception V1 Inception V2 &amp;amp;&amp;amp; V3 Inception V4 Inception ResNet V2 ResNet DetNet前言简单介绍下在2D-detection场景下常用的网络Backbone: VGG-Net Inception ResNet FPN DetNetVGG-NetVGG网络由Oxford的Visual Geometry Group提出,其价值在于探索了卷积网络深度和性能的关系,用更小..." }, { "title": "2D_Detection-基本深度学习单元", "url": "/posts/2D_Detection-%E5%9F%BA%E6%9C%AC%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8D%95%E5%85%83/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-08-06 22:25:12 +0800", "snippet": " 前言 卷积层 传统卷积 可分离卷积 转置卷积(反卷积) 空洞卷积 可形变卷积 激活函数 sigmoid tanh ReLU以及变种 swish 池化层 BN层 GN层 FRN层 Dropout层 全连接层 感受野计算前言深度学习目前在CV（Computer Vision）各个领域都有惊人的进展，从而也衍生了多样的深度学习网络结构；但是诸多复杂的网络结构仍然是基于诸多基础机构组成的，一些定制化的结构也可以..." }, { "title": "2D检测算法综述(2D_Detection)", "url": "/posts/2D%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0(2D_Detection)/", "categories": "算法篇", "tags": "CV, 综述", "date": "2021-07-25 22:25:12 +0800", "snippet": " 前言 公开数据集 经典论文 基本结构 Backbone 超参 Loss 经典检测经典框架 网络加速 通用检测Tricks 部分论文解读Links前言update on 4/10/2021: 终于完成了2D_Detection系列，算是对之前自己在这个领域工作的一点回顾，之后自己会不定期更新一些深度学习模型部署的文章以及论文解读的文章本文旨在总结之前自己涉及的 2D-Detection 相关的知识内容，按照下文组织内容，分篇章不定时更新。主要参考来源： &amp;lt;&amp;lt;深度学习之Pytorch物体检测实战&amp;gt;&amp;gt; 网络: ..." }, { "title": "数据结构与算法(Python)-字符串", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(Python)-%E5%AD%97%E7%AC%A6%E4%B8%B2/", "categories": "数据结构与算法", "tags": "LeetCode, Python", "date": "2021-07-25 21:51:02 +0800", "snippet": " 前言 经典题型 常见运算 判断合理字符串 回文子串 DP算法 Tricks re模块 format使用 前言字符串相关的算法种类相当多，常见的涉及的数据结构/算法有： 递归 栈 DP 双指针经典题型常见运算解法说明：最经典的题型为：通过字符串输入实现加减乘除运算；该类题型的解法通常是将原始的数学解法进行拆分，从而实现分步实现。常用的数据结构是 栈 。真题： 字符串相乘 题解： class Solution(object): def multiply..." }, { "title": "Python语言重点内容梳理", "url": "/posts/_Python%E8%AF%AD%E8%A8%80%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/", "categories": "语言", "tags": "Python", "date": "2021-07-16 22:19:24 +0800", "snippet": "之前简单整理过的简单笔记，但是感觉有点浅尝则止，知识点上不够明确。 本文系列主要为了分章节较为详细地梳理下 Python 的比较重要的知识点(主要基于 极客时间 课程)： Python-基本数据结构 Python-闭包+装饰器 Python-垃圾回收 Python-metaclass Python-上下文管理器 Python-单元测试" }, { "title": "Python-基本数据结构", "url": "/posts/Python-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/", "categories": "语言", "tags": "Python", "date": "2021-07-13 22:19:24 +0800", "snippet": " 基本数据结构 列表和元组 字典和集合Python的基本数据结构包括：列表（list），元组（tuple），字典（dict），集合（set）。基本数据结构 列表是动态的，长度大小不固定，可以随意增/删/修元素 元组是静态的，长度大小固定，无法增/删/修元素 相对于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成 集合和字典基本相同，区别是集合没有键和值的配对，是一系列无序的、唯一的元素集合列表和元组 列表和元组存储方式的差异：列表的存储空间比元祖更大(16字节)，主要包括两个部分：存储指针，指向对应元素（8字节）；存储已经..." }, { "title": "Pytorch关键模块解读", "url": "/posts/Pytorch%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97%E8%A7%A3%E8%AF%BB/", "categories": "算法部署", "tags": "Pytorch", "date": "2021-07-04 21:42:06 +0800", "snippet": "目录 前言 torch.autograd: 梯度计算 BN &amp;amp; SyncBN: BN与多卡同步BN torch.utils.data: 解析数据处理全流程 nn.Module: 核心网络模块接口 DP &amp;amp; DDP: 模型并行和分布式训练 torch.optim: 优化算法接口 torch.cuda.amp: 自动混合精度 cpp_extension: C++/CUDA算子实现和调用全流程前言主要参考：MMLab知乎源码解读torch.autograd: 梯度计算梯度计算主要涉及以下几个模块： torch.autograd.functio..." }, { "title": "基于Jekyll搭建博客", "url": "/posts/%E5%9F%BA%E4%BA%8EJekyll%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/", "categories": "环境配置", "tags": "博客, Jekyll", "date": "2021-06-29 21:56:38 +0800", "snippet": " 前言 搭建博客方案 Jekyll介绍 博客部署 博客评论 Google Analytics前言记录重建博客的过程 工具/环境： PC: mac Code: org-mode，关于org-mode的强大功能可参考Org-mode: Organize your life in plain text! Tool: Spacemacs搭建博客方案&amp;gt;静态网站搭建博客适合专注于内容的博客网站，常见的静态搭建博客网站的方案见：11个最流行的静态网站生成工具。 Octopress/Jekyll对org-mode支持较好，且资源较多，所以采用该解决方案。 博客平台基于Githu..." }, { "title": "3D单目(mono 3D)目标检测算法综述", "url": "/posts/3D%E5%8D%95%E7%9B%AE(mono_3D)%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/", "categories": "算法篇", "tags": "CV, 3D, 综述", "date": "2021-01-22 21:08:39 +0800", "snippet": " 前言 算法调研(相对完善) 2D升3D问题 表达形式(Representation transformation): BEV, Pseudo-Lidar 关键点&amp;amp;&amp;amp;形状 通过2D/3D约束进行距离估计 直接生成3D候选区域(proposal) 关键总结前言翻译自:Monocular 3D Object Detection in Automnonmous Driving-A Review更新monocular 3d object detection相关算法: Add RTMD(01/15..." }, { "title": "Tracking算法综述", "url": "/posts/Tracking%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/", "categories": "算法篇", "tags": "综述, CV, Tracking", "date": "2020-05-31 15:41:56 +0800", "snippet": " 目标跟踪问题定义 目标跟踪算法简述 生成式模型 判别式模型 深度学习方法 目标跟踪问题定义目标跟踪分为密集跟踪(a series detections)和稀疏跟踪(estimation+common sense)。前者本质上对每一帧进行检测，需要更大的计算量，实时性差。所以，一般目标跟踪问题都是指的稀疏跟踪：对检测目标位置进行估计，处理估计位置附近的像素区域，得到待跟踪区域的精确位置，实时性较强。目标跟踪算法简述传统目标跟踪算法按照建模方式的区别分为生成式模型和判别式模型两类（前者对输入输联合分布进行建模，后者直接根据输入输出关系进行..." }, { "title": "OneStage经典-SSD论文精读", "url": "/posts/OneStage%E7%BB%8F%E5%85%B8-SSD%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV", "date": "2020-01-26 23:56:20 +0800", "snippet": "目录 前言 论文基本信息 论文背景以及基本思想(Motivation &amp;amp; Contribution) 算法基本流程 算法细节 实验结果 小结前言SSD作为One-Stage系列的论文，如今已经作为基本网络被广泛应用于物体检测中，也很多网络结构是建立在其基础上的改进网络。当前的Objection Detection架构的两个派系： Two-Stage:基于Region Proposal和CNN网络分类回归方式:RCNN-&amp;gt;SPPnet-&amp;gt;MulriBox-&amp;gt;Faster RCNN，该方案的优势在于检测精度高，但是计算..." }, { "title": "AVOD源码解读", "url": "/posts/AVOD%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "CV, 3D, 源码解读", "date": "2020-01-24 15:35:23 +0800", "snippet": " AVOD代码框架 代码细节 预生成数据 调用链 核心部分 模型训练 调用链 核心部分 AVOD代码框架主要分为以下几个部分: 预生成数据 Train Evaluate+Infer代码细节预生成数据用于生成rpn网络的输入数据：包含类聚类的anchor大小信息以及具体每个sample的anchor的生成的anchor信息调用链base_dir = avod/config = avod..." }, { "title": "F-PointNet论文解读", "url": "/posts/F-PointNet%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2020-01-19 23:56:20 +0800", "snippet": "目录 论文背景以及基本思想 算法基本流程 算法细节Frustum PointNets for 3D Object Detection from RGB-D data论文背景以及基本思想论文出发点：作者认为直接在三维空间内进行点云信息的学习得到3D Box的位置和大小更高效，不会带来点云信息的损失。但是在全局点云上进行卷积过于耗费资源。基于图片可以得到较为准确的2D detection结果，但是位置不精确，所以可以结合两者优势，先通过2D检测得到粗略的3D proposal，再进一步进行精确位置的计算。算法基本流程 流程：论文先采用2d detector在RGB图上得到2D..." }, { "title": "MMF论文解读", "url": "/posts/MMF%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2020-01-15 23:56:20 +0800", "snippet": "目录 论文背景以及基本思想 算法基本流程 算法细节Multi-Task Multi-Sensor Fusion for 3D Object Detection论文背景以及基本思想出发点：基于前作ContFuse的改进，ContFuse虽然融合了Image和Bev的信息，但是对于非常稀疏点云，效果有限。同时，ContFuse的detector head结构过于简单，算法基本流程 核心： 参考AVOD设计了基于ROI-wise fusion的detector head。 进行了ground plane的辅助网络：Unet结构，会预测点云Voxel Spac..." }, { "title": "RoarNet论文解读", "url": "/posts/RoarNet%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2020-01-11 23:56:20 +0800", "snippet": "目录 论文背景以及基本思想 算法基本流程 算法细节RoarNet: A Robust 3D Object Detection based on RegiOn Approximation Refinement论文背景以及基本思想出发点:思想类似于F-ConvNet，认为直接通过2D图片得到3D proposal是不准确的，还可能受不同传感器间的时间不同步的问题，所以提出spatial scattering来对proposal区域进行扩充。算法基本流程 算法思路: RoarNet的整体思路与F-PointNet以及F-ConvNet有点类似。先通过2D的RGB图片通过2..." }, { "title": "F-ConvNet论文解读", "url": "/posts/F-ConvNet%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2020-01-09 23:56:20 +0800", "snippet": "目录 论文背景以及基本思想 算法基本流程 算法细节Frustum ConvNet: Sliding Frustums to Aggregate Local Point-Wise Features for Amodal 3D Object Detection论文背景以及基本思想论文出发点:本文基于F-PointNet的思想，认为F-PointNet非端到端，最终3D Box的预测强依赖于3D点云的分割结果，前置模块的点云缺失会造成后期预测不准确。算法基本流程 核心点: 将2D detection的结果得到的视锥等分为T个部分，对所有视锥部分进行PointNet特征..." }, { "title": "Cont-Fuse论文解读", "url": "/posts/Cont-Fuse%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2020-01-03 23:56:20 +0800", "snippet": "目录 论文背景以及基本思想 算法基本流程 算法细节Deep Continuous Fusion for Multi-Sensor 3D Object Detection论文背景以及基本思想出发点：作者认为Lidar数据与Image数据融合的难点在于怎么将稀疏连续的三维点云信息与语义丰富但是离散的图像数据融合，提出了基于连续卷积的point-wise Fusion的方式进行BEV和Image的深度融合算法基本流程 核心： Fusion Layers的建立：输入为resnet18四个block的输出Image feature，通过FPN进行combine。融合方式为..." }, { "title": "YOLO论文系列解读", "url": "/posts/YOLO%E8%AE%BA%E6%96%87%E7%B3%BB%E5%88%97%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV", "date": "2019-11-13 23:56:20 +0800", "snippet": "目录 前言 论文基本信息 论文出发点和思路 算法基本流程 具体实验分析 YOLOv1个人总结 改进-YOLOv2 出发点 改进方案 改进结果 改进-YOLOv3 出发点 改进方案 改进结果 前言YOLO作为最早的One-stage算法框架，实现了保持较好性能的前提下保证了模型较快的速度和轻便的性能。从Yolov1-&amp;gt;Yolov3，三个版本的迭代也可以很好地观察作者进行性能提升的思路和方法。论文基本信息作者信息:Joseph Redmon,华盛顿大学phD，YOL..." }, { "title": "Numpy常用函数", "url": "/posts/Numpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/", "categories": "语言", "tags": "Numpy, Python", "date": "2019-10-15 15:39:05 +0800", "snippet": " 前言 小结 np常用function Array初始化方法 常规的属性方法 常规的数值方法 常规的Array操作方法 前言Numpy100训练,简单Summary下原始地址:github小结np常用function#info函数,查看函数使用方法,近help()np.info(&quot;add&quot;)#日期相关today = np.datetime64(&#39;today&#39;, &#39;D&#39;)yesterday = today - np.timedelta64(1, &#39;D&#39;..." }, { "title": "AVOD论文解读", "url": "/posts/AVOD%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/", "categories": "算法篇", "tags": "Paper_Reading, CV, 3D", "date": "2019-10-12 23:56:20 +0800", "snippet": "目录 前言 论文基本信息 动机和思路 算法基本流程 具体实验分析 个人总结前言AVOD作为基于Camera信息和Lidar信息融合的3D detection算法，是目前为数不多的开源的SOTA算法之一，相关资料如下：KITTI榜单AVOD论文AVOD源码AVOD源码解读论文基本信息一作信息：Jason Ku 多伦多大学在校研究生，从事无人驾驶感知算法研究其他相关工作：IROS 2019Improving 3D Object Detection for Pedestrians with Virtual Multi-View Synthesis Orientation Estim..." }, { "title": "nms and soft-nms", "url": "/posts/nms_soft-nms/", "categories": "算法篇", "tags": "NMS, CV", "date": "2019-09-15 16:16:24 +0800", "snippet": "Table of Contents nms和soft-nms nms nms代码实现 soft-nms soft-nms代码实现 nms和soft-nmsnms主要是将各个重叠的box清理,得到score最高的主要box,代码步骤实现: 将所有的box框根据score进行升序排列 判断box序列是否为空 保存当前的box序号 计算最高score与其余的box的iou 将iou大于阈值的..." }, { "title": "bash常用命令总结", "url": "/posts/Bash_command/", "categories": "语言", "tags": "Shell", "date": "2019-05-01 23:25:24 +0800", "snippet": "Table of Contents1. grep2. xargs3. sed4. awk5. findgrep查找字符串 ‘-r’:目录查找， grep -r &quot;sample&quot; . ‘-c’:显示匹配数， grep -c &quot;sample&quot; . ‘-i’:忽略大小写 ‘-n’:输出行号xargsxargs将stdin的资料读入，并以空白字元或者断行字元作为分辨，将stdin资料分隔为arguments，其默认的命令为echo,如： echo &quot;\\t&quot; | xargs t ‘-n’ 选择多行输出 ‘-d’ 选..." }, { "title": "emacs配置初步", "url": "/posts/Emcas_Configuration/", "categories": "工具", "tags": "Emacs", "date": "2019-04-20 19:25:24 +0800", "snippet": "Table of Contents1. 前言2. 基本快捷键3. 改变默认的Emacs设置4. 特性相关4.1. 特性的加载与Package的安装4.2. 基本特性介绍4.3. 常用插件介绍前言仅仅emacs入门，先主要将emacs作为一个文本编辑器来使用，学习路线主要参考子龙山人21天emacs ，现在完成了前十天的基础内容现就其中的一些基本操作以及基本 packages 的功能作简单的介绍。个人配置可参考配置地址基本快捷键这里只记录自己常用的一些快捷键：光标切换： C-f,C-b,C-n,C-p 分别为向前，后，上，下移动 C-a,C-e 分别为移动到行首，行末 S-a,S-e..." }, { "title": "Keras样例练习", "url": "/posts/Keras_examples/", "categories": "Tutorial", "tags": "Keras, Tensorflow", "date": "2019-02-23 21:25:24 +0800", "snippet": "Keras应用实例参考自 keras_team实例包括：图像（视频），文字（序列），生成模型，Keras特色功能实现，这里先简单探讨图像和Keras模型功能部分。软件环境：python3.5 tensorflow1.12.0 keras.2.2.4PS: ipynb格式转markdown格式:jupyter nbconvert --to markdown ****.ipynb图像部分Minist_MLP&#39;&#39;&#39;Trains a simple deep NN on the MNIST dataset.20 epochsacc: 0.9816Test loss: 0.1..." }, { "title": "Org-mode基本功能", "url": "/posts/Org_mode/", "categories": "工具", "tags": "Emacs, Org-mode", "date": "2019-01-25 21:25:24 +0800", "snippet": "前言Org mode为Emacs下的一款神器，与markdown这种轻量化格式相比，拥有更多的功能与可拓展性，但是入门还是有一定的难度，这里仅对其中的一些基本功能做简单的的介绍。本文系统Ubuntu下Emacs版本为25.1.1，Org-mode版本为9.2章节序号org-mode以*表示章节标题，*数目表示标题级别：* 一级标题** 二级标题*** 三级标题通过 M-[RET] 键进行同级标题的插入，可以通过 M-left/right 标题的升降级,通过 M-up/down 进行章节内容（包括子章节）的上下替换,可以通过 Tab 键进行章节的展开和折叠， S+Tab 键可以展开、折叠..." }, { "title": "Kaggle-Digit Recognizer-Dimensionality Reduction", "url": "/posts/Kaggle_Digit-Recognizer_Dimensionality-Reduction/", "categories": "Tutorial", "tags": "Kaggle, CV", "date": "2019-01-22 22:56:24 +0800", "snippet": " 参考网页动态图没法动态显示，动态显示效果可参考本人工程Introduction: Principal Component Analysis (PCA) –Unsupervised, liner method Linear Discriminant Analysis (LDA) –Supervised, liner method t-distributed Stochastic Neighbour Embedding (t-SNE) –Nonlinear, probabilstic methodimport numpy as np # linear algebraimport p..." }, { "title": "Kaggle-Digit Recognizer-MLP", "url": "/posts/Kaggle_Digit-Recognizer_MLP/", "categories": "Tutorial", "tags": "Kaggle, CV", "date": "2019-01-22 22:25:24 +0800", "snippet": " 参考网页from keras.models import Sequentialfrom keras.utils import np_utilsfrom keras.layers.core import Dense, Activation, Dropoutimport pandas as pdimport numpy as np# Read datatrain = pd.read_csv(&#39;../input/train.csv&#39;)labels = train.ix[:,0].values.astype(&#39;int32&#39;)X_train = (train.i..." }, { "title": "Kaggle-Digit Recognizer-DCNN", "url": "/posts/Kaggle_Digit-Recognizer_DCNN/", "categories": "Tutorial", "tags": "Kaggle, CV", "date": "2019-01-22 21:25:24 +0800", "snippet": " 参考网页注意点BN层编译部分:Batchnormalization的axis参数在卷积层和池化层应为1（4维数据）Dense层保持默认即可但是对于keras 2,2,4和tensorflow-gpu 1.12会出现错误可参照链接对对应文件进行修改,文件修改如下：if ndim(mean) &amp;gt; 1: #mean = tf.reshape(mean, (-1)) #added by zwg 20190121 mean = tf.reshape(mean, [-1])if ndim(var) &amp;gt; 1: #var = tf.reshape(var, (-1)) #..." }, { "title": "Kaggle-Digit Recognizer-svm", "url": "/posts/Kaggle_Digit-Recognizer_svm/", "categories": "Tutorial", "tags": "Kaggle, CV", "date": "2019-01-22 19:25:24 +0800", "snippet": " 参考网页import pandas as pdimport matplotlib.pyplot as plt, matplotlib.image as mpimgfrom sklearn.model_selection import train_test_splitfrom sklearn import svm%matplotlib inlinelabeled_images = pd.read_csv(&#39;../input/train.csv&#39;)images = labeled_images.iloc[0:5000,1:]labels = labeled_images...." }, { "title": "Ubuntu16.04LTS+Tensorflow基本环境配置", "url": "/posts/Ubuntu16.04LTS_Cuda9.0_OpenCV3_python_tensorflow/", "categories": "环境配置", "tags": "Ubuntu, Tensorflow, CUDA, OpenCV", "date": "2018-11-20 19:25:24 +0800", "snippet": " 参考博客系统：Ubuntu16 （kernel：141）安装Cuda驱动采用下载文件安装，在系统设置选择软件和更新，更改下载源，选择aliyun，选择附件驱动，选择使用NVIDA binary driver.......nvidia-384:提示重启后，终端输入：sudo nvidia-settings弹出界面：则说明安装成功。通过nvidia-smi也可以得到GPU信息。安装Cuda官网下载cuda9.0的deb文件。安装：sudo dpkg -i cuda-repo-ubuntu1604-9-0-local_9.0.176-1_amd64.deb(下载的文件名)# Install..." }, { "title": "Turtlebot2i软件包的安装与配置", "url": "/posts/TurtleBot2i_Installation/", "categories": "环境配置", "tags": "Turtlebot2i, ROS", "date": "2018-04-20 19:25:24 +0800", "snippet": "概述：Turtlebot2i是针对turtlebot2-arm版本的软件安装包，这里简单介绍一下它的的安装与编译，根据实际情况与官方教程有所不同。本文的软件安装过程：先安装ROS-kinetic基本功能包-测试主从机ssh通信-配置Turtlebot2i软硬件。硬件列表Kubuki底座；sr300摄像头；astra摄像头；phantomx机械臂，工控机（这里我用了自己的笔记本代替）。软件列表系统：ubuntu16 LTS(建议安装最新核的系统，本人系统核为4.13.0-32-generic，用uname -r命令查看,ubuntu14编译需要更改相关库文件以及部分lanuch文件)Ros..." }, { "title": "ROS下Astra Pro和RealSense摄像头配置", "url": "/posts/ROS_Astra_RealaSense/", "categories": "环境配置", "tags": "ROS, RGB-D摄像头", "date": "2018-04-19 19:25:24 +0800", "snippet": "概述：系统：ubuntu14.04.5(64)+ASTRA+SR300摄像头摄像头型号：ORBBEC Astra摄像头+RealSense SR300ROS版本：Indigo versionNote:驱动的安装和系统版本有关系，所以务必使用支持更新的系统版本，这里使用的是ubuntu14.04.5,另外github上的程序包因为会不断更新，所以部分文件会有不同，注意版本。ORBBEC Astra驱动安装请在下面网址，分别下载对应包：Package1,Package2也可以直接下载打包好的资源：安装包首先安装驱动，依据版本选择下载驱动中合适的版本：OpenNI-Linux-x64-2.3安..." }, { "title": "ROS与PhantomXArm机械臂配置", "url": "/posts/ROS_PhantomXArm/", "categories": "环境配置", "tags": "ROS, PhantomXArm", "date": "2018-04-19 18:25:24 +0800", "snippet": "硬件接线机械臂与排线相连，三个端口等效:FTDI串口线，直接与电脑相连(确定方向不要接反)：管脚控制USB供电（USB），或者电源线接电（VIN）：电源线接12V5A电源：安装Arduiomkdir ~/toolscd ~/tools下载arduino-1.05或者1.06 解压缩到当前目录，启动arduino~/tools/arduino-1.0.5/arduino安装arbotix包：sudo apt-get updatesudo apt-get install ros-indigo-arbotix下载arbotix 源码：cd ~/tools/git clone https://g..." }, { "title": "Ubuntu16系统的备份与迁移", "url": "/posts/Ubuntu_System_Backups/", "categories": "环境配置", "tags": "Ubuntu, 系统备份", "date": "2018-02-06 19:25:24 +0800", "snippet": "概述：关于ubuntu系统的备份与恢复，网上资料很多，但多是错误或者不全的。这里介绍一下正确的系统备份与恢复的步骤，也可以在不同的电脑上拷贝自己的系统。值得注意的是，为了系统恢复的方便，自己系统的分区为：主分区（/），home分区（/home)，交换空间，以及boot分区（/boot）。这里进行了分别备份，以供不同的恢复需求。采用的是livecd的恢复方式，因为自己用tar方式备份，直接删除文件有错误，所以直接用livdcd的方式。PS: 这里没有考虑efi系统分区，实际步骤类似，但是对不支持efi分区的电脑就会出错。部分图片引自IT之家，侵删。硬件需求Ubuntu系统U盘（livecd..." }, { "title": "Win7下基于Qt和opencv的程序的运行", "url": "/posts/Win7_Qt_opencv_static_compilation/", "categories": "环境配置", "tags": "Qt, 静态编译", "date": "2017-05-13 19:25:24 +0800", "snippet": "Qt的静态编译Qt的版本：qt-opensource-windows-x86-mingw491_opengl-5.4.0.exe注意点：安装组件的时候要注意全选组件Qt的静态库安装：这里没有编译静态库，直接使用网上下载的release版本的Qt静态库：下载后直接可以用静态库进行配置,把静态库集成到QtCreator里面: 打开QtCreator的菜单工具–》选项; 然后对话框左边选择构建和运行; 在构建和运行页面，右边选择Qt Versions; 点击右上角添加，会弹出查找qmake.exe的对话框，找到刚才装的静态库安装目录\\5.3.2\\bin\\qmake.exe; 点击确定..." }, { "title": "Ubuntu16LTS+Caffe基本环境配置", "url": "/posts/Ubuntu16LTS+Cuda8+OpenCV3+Maltlab2014a+python+Caffe/", "categories": "环境配置", "tags": "Ubuntu, OpenFace, Caffe", "date": "2016-12-10 19:25:24 +0800", "snippet": "layout: posttitle:date: 2021-06-23 22:11:23.000000000 +09:00categories: []tags: []— 参考博客安装Cuda驱动采用下载文件安装，在系统设置选择软件和更新，更改下载源，选择aliyun，选择附件驱动，选择使用NVIDA binary driver.......nvidia-367提示重启后，终端输入：sudo nvidia-settings弹出界面如下：说明驱动安装成功，通过nvidia-smi也可以得到GPU信息。安装Cuda8官网下载cuda8.0的deb文件，安装：sudo dpkg -i xxxxx..." }, { "title": "OpenFace自建CNN模型", "url": "/posts/OpenFace_CNN_model/", "categories": "Tutorial", "tags": "OpenFace, CV", "date": "2016-11-25 19:25:24 +0800", "snippet": "Openface Home 重点可参考：杨存毅的博客OpenFace官方网站：https://cmusatyalab.github.io/openface/https://cmusatyalab.github.io/openface/setup/环境配置Ubuntu16.04Nvidia 940MCuda8.0库环境OpenCV2.4.11与cuda8.0具有一定的冲突性，可以安装opencv2.4.13，本机安装的是opencv3.10.OpenCV2.4.13可参照官方教程（未测试）OpenCV3.1的安装过程如下：[compiler] sudo apt-get install b..." }, { "title": "Ubuntu16常用软件安装", "url": "/posts/Ubuntu_Software_configuration/", "categories": "环境配置", "tags": "Ubuntu", "date": "2016-11-22 19:25:24 +0800", "snippet": "概述：Ubuntu16下的基本软件环境设置自带软件卸载Libreoffice,amazon链接等，删除基本不用的自带软件:sudo apt-get autoremove libreoffice*sudo apt-get autoremove unity-webapps-commonsudo apt-get autoremove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca w..." }, { "title": "双系统安装(WIN10+Ubuntu16)", "url": "/posts/Win10_Ubuntu_installation/", "categories": "环境配置", "tags": "双系统", "date": "2016-11-17 19:25:24 +0800", "snippet": "Windows下的安装准备插入U盘（最好删除其他文件），打开ULtraiso软件(可选下载地址)，打开Ubuntu16.04 ISO文件(可选下载地址:ubuntu-16.04.7-desktop-amd64.iso)，启动-&amp;gt;写入硬盘映像，选择自己的U盘，选择便捷启动，开始写入。划分硬盘分区（50G为例）：Win10下，右键点击Windows键（Windows+X）选择磁盘管理；进入磁盘管理之后，选择分区的磁盘（建议选择最后一个磁盘），右键，选择压缩卷，系统会自动查询压缩空间，然后选择需要压缩的空间，这里选择50G，点击压缩，压缩成功（这里不需要新建压缩卷）。Ubuntu..." }, { "title": "Ubuntu安装OpenFace", "url": "/posts/Ubuntu16_OpenFace_installation/", "categories": "环境配置", "tags": "OpenFace", "date": "2016-11-15 19:25:24 +0800", "snippet": "安装准备sudo apt-get install build-essential -ysudo apt-get install cmake -ysudo apt-get install curl -ysudo apt-get install gfortran -ysudo apt-get install git -ysudo apt-get install libatlas-dev -ysudo apt-get install libavcodec-dev -ysudo apt-get install libavformat-dev -ysudo apt-get install libb..." }, { "title": "浙大玉泉Ubuntu VPN设置", "url": "/posts/Ubuntu_VPN_configuration/", "categories": "环境配置", "tags": "ZJU, VPN", "date": "2016-07-05 19:25:24 +0800", "snippet": "概述：针对浙大玉泉校区的Ubuntu下的VPN设置内网有线IP设置玉泉有线都是要绑定固定ip的，实验室无需和mac地址绑定，命令如下:sudo gedit /etc/network/interfaces需要先ifconfig确定网卡号说明：DNS也在这里直接设置了，不要去/etc/resolv.conf里设置，那个只是临时的，开机就又没用了。寝室里需要绑定mac地址请自行googleauto eth0iface eth0 inet staticaddress /你的ip/netmask 255.255.255.0gateway /你的网关/dns-nameservers 10.10.0...." } ]
